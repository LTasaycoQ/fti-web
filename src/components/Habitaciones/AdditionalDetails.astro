---
import RoomIncludes from "./RoomIncludes.astro";

import { roomsData } from "../../content/RoomClasic/service";
import "../../assets/styles/global.css";
---

{
  roomsData.map((room) => {
    const half = Math.ceil(room.services.length / 2);
    const col1 = room.services.slice(0, half);
    const col2 = room.services.slice(half);
    return (
      <section class="mb-20">
        <h2 class="text-gray-700 position__title title text-[1.8rem]">
          {room.title}
        </h2>

        <div class="w-full flex justify-center gap-[30px] items-center mb-8">
          <button aria-label="Anterior" class="prevBtn">
            <i class="bi bi-caret-left-fill bg-red-900 w-[2.2em] text-white p-2 rounded-full text-[20px]" />
          </button>

          <div class="slider__rooms flex justify-start items-center overflow-x-scroll scroll-smooth gap-[20px] p-[20px] w-[78%]">
            {room.images.map((img) => (
              <img
                src={img}
                alt={room.title}
                class="w-[24em] max-md:w-[45em]"
                draggable="false"
              />
            ))}
          </div>

          <button aria-label="Siguiente" class="nextBtn">
            <i class="bi bi-caret-right-fill bg-red-900 w-[2.2em] text-white p-2 rounded-full text-[20px]" />
          </button>
        </div>

        <div class="lista__detail w-full flex justify-center items-center">
          <RoomIncludes />
        </div>

        <h3 class="text-gray-700 text-[1.4rem] title">{room.titleService}</h3>

        <div class="lista__detail text-[18px] flex flex-wrap gap-[40px] justify-center items-center">
          <ul class="flex flex-col justify-start items-start">
            {col1.map((item) => (
              <li class="flex gap-[10px] items-center justify-center text-gray-600">
                <i class="text-[#9E2222] text-[18px] bi bi-check-lg" />
                {item}
              </li>
            ))}
          </ul>

          <ul class="flex flex-col justify-start items-start">
            {col2.map((item) => (
              <li class="flex gap-[10px] items-center justify-center text-gray-600">
                <i class="text-[#9E2222] text-[18px] bi bi-check-lg" />
                {item}
              </li>
            ))}
          </ul>
        </div>
      </section>
    );
  })
}

<style>
  .lista__detail {
    margin-bottom: 70px;
    margin-top: 40px;
  }

  .slider__rooms {
  cursor: grab;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none; /* Firefox */
}

.slider__rooms::-webkit-scrollbar {
  display: none; /* Chrome, Safari */
}

.slider__rooms img {
  pointer-events: none; /* Evita conflictos con drag */
  user-select: none;
}
</style>


<script type="module">

  document.addEventListener("DOMContentLoaded", () => {
  const sliders = document.querySelectorAll(".slider__rooms");
  
  sliders.forEach((slider) => {
    const prevBtn = slider.parentElement.querySelector(".prevBtn");
    const nextBtn = slider.parentElement.querySelector(".nextBtn");
    const images = Array.from(slider.children);
    
    // Solo clonamos el primer y último elemento (más eficiente)
    const firstClone = images[0].cloneNode(true);
    const lastClone = images[images.length - 1].cloneNode(true);
    
    slider.appendChild(firstClone);
    slider.insertBefore(lastClone, slider.firstChild);
    
    let currentIndex = 1; // Empezamos en la primera imagen real
    const totalSlides = images.length;
    
    const updateSlider = (smooth = true) => {
      const imageWidth = images[0].offsetWidth + 20;
      slider.style.scrollBehavior = smooth ? 'smooth' : 'auto';
      slider.scrollLeft = currentIndex * imageWidth;
    };
    
    // Inicializar posición
    updateSlider(false);
    
    // Navegación con botones
    nextBtn.addEventListener("click", () => {
      currentIndex++;
      updateSlider(true);
    });
    
    prevBtn.addEventListener("click", () => {
      currentIndex--;
      updateSlider(true);
    });
    
    // Detectar fin de transición para loop infinito
    slider.addEventListener("scrollend", () => {
      if (currentIndex === 0) {
        currentIndex = totalSlides;
        updateSlider(false);
      } else if (currentIndex === totalSlides + 1) {
        currentIndex = 1;
        updateSlider(false);
      }
    });
    
    // Drag mejorado
    let isDragging = false;
    let startX, startScrollLeft;
    
    slider.addEventListener("mousedown", (e) => {
      isDragging = true;
      slider.style.cursor = 'grabbing';
      slider.style.scrollBehavior = 'auto';
      startX = e.pageX;
      startScrollLeft = slider.scrollLeft;
    });
    
    slider.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const x = e.pageX;
      const walk = (startX - x) * 1.5; // Velocidad del drag
      slider.scrollLeft = startScrollLeft + walk;
    });
    
    const stopDragging = () => {
      if (!isDragging) return;
      isDragging = false;
      slider.style.cursor = 'grab';
      
      // Snap al slide más cercano
      const imageWidth = images[0].offsetWidth + 20;
      currentIndex = Math.round(slider.scrollLeft / imageWidth);
      updateSlider(true);
    };
    
    slider.addEventListener("mouseup", stopDragging);
    slider.addEventListener("mouseleave", stopDragging);
    
    // Soporte táctil
    slider.addEventListener("touchstart", (e) => {
      startX = e.touches[0].pageX;
      startScrollLeft = slider.scrollLeft;
    });
    
    slider.addEventListener("touchmove", (e) => {
      const x = e.touches[0].pageX;
      const walk = (startX - x) * 1.5;
      slider.scrollLeft = startScrollLeft + walk;
    });
    
    slider.addEventListener("touchend", () => {
      const imageWidth = images[0].offsetWidth + 20;
      currentIndex = Math.round(slider.scrollLeft / imageWidth);
      updateSlider(true);
    });
  });
});
</script>